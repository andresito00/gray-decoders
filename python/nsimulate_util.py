import argparse
import numpy as np
import scipy.io as io

def build_args():
    parser = argparse.ArgumentParser()

    # main parameters
    parser.add_argument(
      '--mode', '-m',
      type=str,
      default='synthetic',
      choices=['file', 'tune', 'synthetic', 'sim3_1', 'simulate'],
      help='synthetic spikes generated by prob. distribution or file input'
    )

    parser.add_argument(
      '--show', '-s',
      action='store_true',
      default=False,
      help='whether or not to show the plots'
    )

    parser.add_argument(
      '--lat', '-l',
      action='store_true',
      default=False,
      help='whether or not to measure script latencies'
    )

    # file input parameters
    parser.add_argument(
      '--mat-file', '-mf',
      type=str,
      help='filename argument for a .matfile (hardcoded to 100x8 array of'
          'structs containing 2-D arrays)'
    )

    # tuning curve parameters
    parser.add_argument(
      '--dirs', '-d',
      nargs='+',
      default=[10, 20, 30],
      type=int,
      help='list of the potential reach directions in units of degrees'
    )

    parser.add_argument(
      '--rates', '-r',
      nargs='+',
      type=int,
      help='rate in spikes/s'
    )

    # probability distribution parameters
    parser.add_argument(
      '--type', '-t',
      type=str,
      default='Poisson',
      choices=['Poisson'],
      help='type of synthetic data'
    )

    parser.add_argument(
      '--shift', '-sh',
      type=int,
      default=20,
      help='dc shift or offset of the probability distribution'
    )

    parser.add_argument(
      '--dists', '-td',
      type=int,
      default=10,
      help='target distance in units of cm'
    )

    parser.add_argument(
      '--rand', '-rn',
      type=str,
      choices=['EXP', 'GAMMA', 'POISSON'],
      help='type of random variable'
    )

    parser.add_argument(
      '--pref-dir', '-pd',
      type=int,
      default=45,
      help='preferred target direction in units of degrees'
    )

    parser.add_argument(
      '--num-trials', '-n',
      type=int,
      default=10,
      help='the number of trials we\'ll generate for each target'
    )

    # raster generation parameters
    parser.add_argument(
      '--intervals', '-dt',
      nargs='+',
      type=int,
      help='the intervals of the stimuli in units of milliseconds'
    )

    parser.add_argument(
      '--bin-size', '-b',
      type=int,
      default=10,
      help='the binning resolution at which to capture the millisecond data'
    )

    return parser.parse_args()

def parse_mat_file(mat_file: str):
    """
    think of matContents as a 2-D matrix where
    the rows are each trial
    the columns are each motor function target
    each cell in the matrix contains a structure with another 2-D matrix where
    the rows are each each neuron sensor
    the columns are millisecond, where 1 implies an action potential firing has been detected by that sensor
    """

    varName = io.whosmat(mat_file)[0][0]
    matContents = io.loadmat(mat_file)

    plan_training_data = matContents[varName]

    numTrials = plan_training_data.shape[0]  # m = rows
    numTargets = plan_training_data.shape[1] # n  = columns

    # dimensions will always be referred to as "m x n"

    trials = []
    for i in range(0, numTrials):

        targets = []
        for j in range(0, numTargets):

            # the 1st dimension of this internal structure contains the actual spike train data (a 2-D matrix)
            targets.append(plan_training_data[i,j][1])

        trials.append(targets)

    # convert the list of lists (of 2-D arrays) to a 4-dimensional numpy array such that
    # the dimensions are, in order, [trial, target, sensor, neural spike/ms]
    trials = np.asarray(trials)

    outputDir = "parser_output/"
    filename, extension = mat_file.split('.')

    # the following loops save all trial data to a .txt file for each target
    for n in range(0, numTargets):
        print("Now parsing target " + str(n) + "...")
        with open(outputDir + filename + "_target" + str(n) + ".txt",'w') as f:

            for m in range(0, numTrials-1):
                curr_trial = trials[m,n,:,:]
                next_trial = trials[m+1,n,:,:]
                curr_trial = np.concatenate((curr_trial, next_trial), axis=1)

            # the following is the current format that the meschach matrix file input function expects to receive.
            f.write("Matrix: " + str(curr_trial.shape[0]) +  " by " + str(curr_trial.shape[1]) + "\n")

            # faster now that we've concatenated our training trials...
            np.savetxt(f, curr_trial, delimiter=' ', fmt='%i')

